/*
 * generated by Xtext 2.10.0
 */
package com.github.funthomas424242.dsl.serializer;

import com.github.funthomas424242.dsl.ahnen.AhnenPackage;
import com.github.funthomas424242.dsl.ahnen.Autor;
import com.github.funthomas424242.dsl.ahnen.Beziehung;
import com.github.funthomas424242.dsl.ahnen.Dateiart;
import com.github.funthomas424242.dsl.ahnen.Familie;
import com.github.funthomas424242.dsl.ahnen.FamilienImport;
import com.github.funthomas424242.dsl.ahnen.Familienbuch;
import com.github.funthomas424242.dsl.ahnen.Kinder;
import com.github.funthomas424242.dsl.ahnen.Model;
import com.github.funthomas424242.dsl.ahnen.Person;
import com.github.funthomas424242.dsl.ahnen.Schulausbildung;
import com.github.funthomas424242.dsl.ahnen.Taetigkeit;
import com.github.funthomas424242.dsl.services.AhnenGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AhnenSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AhnenGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AhnenPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AhnenPackage.AUTOR:
				sequence_Autor(context, (Autor) semanticObject); 
				return; 
			case AhnenPackage.BEZIEHUNG:
				sequence_Beziehung(context, (Beziehung) semanticObject); 
				return; 
			case AhnenPackage.DATEIART:
				sequence_Dateiart(context, (Dateiart) semanticObject); 
				return; 
			case AhnenPackage.FAMILIE:
				sequence_Familie(context, (Familie) semanticObject); 
				return; 
			case AhnenPackage.FAMILIEN_IMPORT:
				sequence_FamilienImport(context, (FamilienImport) semanticObject); 
				return; 
			case AhnenPackage.FAMILIENBUCH:
				sequence_Familienbuch(context, (Familienbuch) semanticObject); 
				return; 
			case AhnenPackage.KINDER:
				sequence_Kinder(context, (Kinder) semanticObject); 
				return; 
			case AhnenPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AhnenPackage.PERSON:
				sequence_Person(context, (Person) semanticObject); 
				return; 
			case AhnenPackage.SCHULAUSBILDUNG:
				sequence_Schulausbildung(context, (Schulausbildung) semanticObject); 
				return; 
			case AhnenPackage.TAETIGKEIT:
				sequence_Taetigkeit(context, (Taetigkeit) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Autor returns Autor
	 *
	 * Constraint:
	 *     (vorname=STRING nachname=STRING organisationsName=STRING?)
	 */
	protected void sequence_Autor(ISerializationContext context, Autor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Beziehung returns Beziehung
	 *
	 * Constraint:
	 *     (beziehung=[Person|STRING]? vonDatum=DATUM? bisDatum=DATUM? hochzeitstag=DATUM? scheidungstag=DATUM?)
	 */
	protected void sequence_Beziehung(ISerializationContext context, Beziehung semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Dateiart returns Dateiart
	 *
	 * Constraint:
	 *     (buch=Familienbuch | familie=Familie)
	 */
	protected void sequence_Dateiart(ISerializationContext context, Dateiart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Familie returns Familie
	 *
	 * Constraint:
	 *     (name=ID personen+=Person+)
	 */
	protected void sequence_Familie(ISerializationContext context, Familie semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FamilienImport returns FamilienImport
	 *
	 * Constraint:
	 *     familie=[Familie|ID]
	 */
	protected void sequence_FamilienImport(ISerializationContext context, FamilienImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AhnenPackage.Literals.FAMILIEN_IMPORT__FAMILIE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AhnenPackage.Literals.FAMILIEN_IMPORT__FAMILIE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFamilienImportAccess().getFamilieFamilieIDTerminalRuleCall_2_0_1(), semanticObject.getFamilie());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Familienbuch returns Familienbuch
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         familie=STRING 
	 *         person=[Person|STRING] 
	 *         version=VERSION 
	 *         titel=STRING 
	 *         vorwort=STRING 
	 *         autor=Autor 
	 *         familien+=FamilienImport+
	 *     )
	 */
	protected void sequence_Familienbuch(ISerializationContext context, Familienbuch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Kinder returns Kinder
	 *
	 * Constraint:
	 *     (kind=[Person|STRING]? next=Kinder?)
	 */
	protected void sequence_Kinder(ISerializationContext context, Kinder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     datei=Dateiart
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AhnenPackage.Literals.MODEL__DATEI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AhnenPackage.Literals.MODEL__DATEI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getDateiDateiartParserRuleCall_0(), semanticObject.getDatei());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Person returns Person
	 *
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         letzteAenderung=DATUM 
	 *         vorname=STRING? 
	 *         mittelname=STRING? 
	 *         nachname=STRING? 
	 *         geburtsname=STRING? 
	 *         rufname=STRING? 
	 *         geschlecht=Geschlecht? 
	 *         geburtsDatum=DATUM? 
	 *         todesDatum=DATUM? 
	 *         vater=[Person|STRING]? 
	 *         mutter=[Person|STRING]? 
	 *         kinder=Kinder? 
	 *         stiefkinder=Kinder? 
	 *         beziehungen+=Beziehung* 
	 *         ereignisse+=Ereignis*
	 *     )
	 */
	protected void sequence_Person(ISerializationContext context, Person semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ereignis returns Schulausbildung
	 *     Schulausbildung returns Schulausbildung
	 *
	 * Constraint:
	 *     (von=DATUM? bis=DATUM? abschluss=STRING?)
	 */
	protected void sequence_Schulausbildung(ISerializationContext context, Schulausbildung semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ereignis returns Taetigkeit
	 *     Taetigkeit returns Taetigkeit
	 *
	 * Constraint:
	 *     (beruf=STRING? arbeitgeber=STRING? ort=STRING? von=DATUM? bis=DATUM?)
	 */
	protected void sequence_Taetigkeit(ISerializationContext context, Taetigkeit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
